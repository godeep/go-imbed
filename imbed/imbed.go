// Copyright 2017 Alexey Naidyonov. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE.md file.

/*
   Package github.com/growler/go-imbed/imbed
*/
package imbed

//go:generate go run -tags bootstrap ../cmd.go --no-http-helper --filesystem _templates internal/templates

import (
	"bytes"
	"compress/gzip"
	"encoding/base32"
	"encoding/binary"
	"fmt"
	"go/format"
	"hash/crc64"
	"io"
	"io/ioutil"
	"mime"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// Embedding parameters
type ImbedParams struct {
	// Compress assets whenever possible
	CompressAssets bool
	// Build FileSystem API
	BuildFsAPI bool
	// Build http.FileSystem API
	BuildHttpFsAPI bool
	// Build http.Server helper API
	BuildHttpHelperAPI bool
	// Build raw data access API (dangerous)
	BuildRawAccessAPI bool
	has404Asset       bool
}

type directoryAsset struct {
	name  string
	dirs  []directoryAsset
	files []*fileAsset
}

type fileAsset struct {
	name         string
	mimeType     string
	tag          string
	size         int64
	isCompressed bool
	offStart     int
	offStop      int
}

func buildIndex(d *directoryAsset, params *ImbedParams) (string, string) {
	var dir bytes.Buffer
	var index bytes.Buffer
	addIndent(&dir, 1)
	dir.WriteString("root = &directoryAsset")
	buildDirIndex(params, &dir, &index, d, "", "root", 1)
	dir.WriteRune('\n')
	return dir.String(), index.String()
}

func addIndent(buf *bytes.Buffer, n int) {
	for i := 0; i < n; i++ {
		buf.WriteByte('\t')
	}
}

func buildDirIndex(params *ImbedParams, dir *bytes.Buffer, index *bytes.Buffer, d *directoryAsset, p, indexPrefix string, indent int) {
	dir.WriteString("{\n")
	if d.name != "" {
		addIndent(dir, indent+1)
		fmt.Fprintf(dir, "name: \"%s\",\n", d.name)
	}
	if len(d.dirs) > 0 {
		addIndent(dir, indent+1)
		dir.WriteString("dirs: []directoryAsset{\n")
		for i := range d.dirs {
			addIndent(dir, indent+2)
			buildDirIndex(params, dir, index, &d.dirs[i], path.Join(p, d.dirs[i].name), fmt.Sprintf("%s.dirs[%d]", indexPrefix, i), indent+2)
			dir.WriteString(",\n")
		}
		addIndent(dir, indent+1)
		dir.WriteString("},\n")
	}
	if len(d.files) > 0 {
		addIndent(dir, indent+1)
		dir.WriteString("files: []Asset{\n")
		for i := range d.files {
			fn := d.files[i].name
			addIndent(dir, indent+2)
			d.files[i].writeDefinition(dir, indent+2, params)
			dir.WriteString(",\n")
			addIndent(index, 1)
			fmt.Fprintf(index, "idx[\"%s\"] = &%s.files[%d]\n", path.Join(p, fn), indexPrefix, i)
			if params.BuildHttpHelperAPI && (fn == "index.html" || fn == "index.htm") {
				addIndent(index, 1)
				fmt.Fprintf(index, "idx[\"%s\"] = &%s.files[%d]\n", p, indexPrefix, i)
			}
			if params.BuildHttpHelperAPI && p == "" && (fn == "404.html" || fn == "404.htm") {
				addIndent(index, 1)
				fmt.Fprintf(index, "http404Asset = &%s.files[%d]\n", indexPrefix, i)
				params.has404Asset = true
			}
		}
		addIndent(dir, indent+1)
		dir.WriteString("},\n")
	}
	addIndent(dir, indent)
	dir.WriteString("}")
}

func (f *fileAsset) writeDefinition(w *bytes.Buffer, ind int, params *ImbedParams) {
	fmt.Fprint(w, "{\n")
	addIndent(w, ind+1)
	fmt.Fprintf(w, "name:         \"%s\",\n", f.name)
	addIndent(w, ind+1)
	fmt.Fprintf(w, "blob:         bb[%d:%d],\n", f.offStart, f.offStop)
	addIndent(w, ind+1)
	fmt.Fprintf(w, "str_blob:     bs[%d:%d],\n", f.offStart, f.offStop)
	addIndent(w, ind+1)
	fmt.Fprintf(w, "mime:         \"%s\",\n", f.mimeType)
	addIndent(w, ind+1)
	fmt.Fprintf(w, "tag:          \"%s\",\n", f.tag)
	addIndent(w, ind+1)
	fmt.Fprintf(w, "size:         %d,\n", f.size)
	if params.CompressAssets {
		addIndent(w, ind+1)
		fmt.Fprintf(w, "isCompressed: %v,\n", f.isCompressed)
	}
	addIndent(w, ind)
	fmt.Fprint(w, "}")
}

func (d *directoryAsset) addDirectory(name string) {
	if name == "." {
		return
	}
	elts := strings.Split(name, "/")
	if len(elts) == 1 {
		d.dirs = append(d.dirs, directoryAsset{
			name: elts[0],
		})
	} else {
		for i := range d.dirs {
			if d.dirs[i].name == elts[0] {
				d.dirs[i].addDirectory(path.Join(elts[1:]...))
				return
			}
		}
		panic("directory not found")
	}
}

func (d *directoryAsset) addFile(name string, file *fileAsset) {
	elts := strings.Split(name, "/")
	if len(elts) == 1 {
		d.files = append(d.files, file)
	} else {
		for i := range d.dirs {
			if d.dirs[i].name == elts[0] {
				d.dirs[i].addFile(path.Join(elts[1:]...), file)
				return
			}
		}
		panic("directory not found")
	}
}

var b32Enc = base32.NewEncoding("abcdefghijklmnopqrstuvwxyz234567").WithPadding(base32.NoPadding)

const objectFileHeaderTemplate = `// Code generated by go-imbed. DO NOT EDIT.

#include "textflag.h"

`

const objectFileFooterTemplate = `GLOBL ·d(SB),RODATA,$%d
`

func writeObjectFileHeader(file *os.File) error {
	_, err := file.WriteString(objectFileHeaderTemplate)
	return err
}

func writeObjectFileFooter(file *os.File, size int) error {
	_, err := fmt.Fprintf(file, objectFileFooterTemplate, size)
	return err
}

func (a *fileAsset) writeObject(input *os.File, output *os.File, start int, params *ImbedParams) (int, error) {
	var compressor *gzip.Writer
	var err error
	if _, err := input.Seek(0, 0); err != nil {
		return 0, err
	}
	crc := uint64(0)
	crcTable := crc64.MakeTable(crc64.ECMA)
	pipeIn, pipeOut := io.Pipe()
	if a.isCompressed {
		compressor, _ = gzip.NewWriterLevel(pipeOut, gzip.BestCompression)
	}
	go func() {
		buf := make([]byte, 8192)
		for {
			n, err := input.Read(buf)
			if err == io.EOF {
				if a.isCompressed {
					compressor.Close()
				}
				break
			} else if err != nil {
				pipeOut.CloseWithError(err)
				return
			}
			crc = crc64.Update(crc, crcTable, buf[:n])
			if a.isCompressed {
				_, err = compressor.Write(buf[:n])
			} else {
				_, err = pipeOut.Write(buf[:n])
			}
			if err != nil {
				pipeOut.CloseWithError(err)
				return
			}
		}
		pipeOut.Close()
	}()
	defer pipeIn.Close()
	buf := [8]byte{}
	_sbuf := [32]byte{}
	addr := start
	size := 0
	read := 0
	for {
		if read, err = io.ReadFull(pipeIn, buf[:]); err != nil {
			if err == io.EOF {
				break
			} else if err != io.ErrUnexpectedEOF {
				return 0, err
			}
		}
		for i := read; i < 8; i++ {
			buf[i] = 0
		}
		var sbuf = _sbuf[0:0]
		for i := range buf {
			sbuf = append(sbuf, []byte("\\x")...)
			if buf[i] < 0x10 {
				sbuf = append(sbuf, '0')
			}
			sbuf = strconv.AppendUint(sbuf, uint64(buf[i]), 16)
		}
		_, err = fmt.Fprintf(output, "DATA ·d+%d(SB)/8,$\"%s\"\n", addr, string(sbuf))
		if err != nil {
			return 0, err
		}
		size += read
		addr += 8
	}
	var crcBuf [8]byte
	binary.LittleEndian.PutUint64(crcBuf[:], crc)
	a.tag = b32Enc.EncodeToString(crcBuf[:])
	a.offStart = start
	a.offStop = start + size
	return addr, nil
}

func writeGoIndex(file *os.File, pkg string, root *directoryAsset, addr int, params *ImbedParams) error {
	timestamp := time.Now()
	dir, index := buildIndex(root, params)
	buf := bytes.Buffer{}
	err := iMustHazTemplate("index.go").Execute(&buf, map[string]interface{}{
		"Pkg":           path.Base(pkg),
		"Size":          addr,
		"IndexCode":     index,
		"DirectoryCode": dir,
		"Date":          fmt.Sprintf("%d,%d", timestamp.Unix(), timestamp.Nanosecond()),
		"Params":        params,
		"Has404Asset":   params.BuildHttpHelperAPI && params.has404Asset,
	})
	if err != nil {
		return err
	}
	format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	_, err = file.Write(buf.Bytes())
	return err
}

func writeAsmIndex(target string) error {
	for _, file := range iMustHazAsmList() {
		src := iMustHazFile(file)
		targetFile, err := ioutil.TempFile(target, "indexasm")
		if err != nil {
			return err
		}
		if _, err = targetFile.WriteString(src); err != nil {
			targetFile.Close()
			os.Remove(targetFile.Name())
			return err
		}
		if err = targetFile.Close(); err != nil {
			os.Remove(targetFile.Name())
			return err
		}
		if err = os.Rename(targetFile.Name(), path.Join(target, file)); err != nil {
			os.Remove(targetFile.Name())
			return err
		}
	}
	return nil
}

// Creates a Go package from `source` directory contents. Package name will
// be basename (i.e. last element) of the `target` path.
func Imbed(source, target string, params ImbedParams) error {
	params.BuildFsAPI = params.BuildFsAPI || params.BuildHttpFsAPI
	err := os.MkdirAll(target, 0755)
	if err != nil {
		return err
	}
	dataFile, err := ioutil.TempFile(target, "data")
	if err != nil {
		return err
	}
	defer os.Remove(dataFile.Name())
	err = writeObjectFileHeader(dataFile)
	if err != nil {
		return err
	}
	indexFile, err := ioutil.TempFile(target, "index")
	if err != nil {
		return err
	}
	defer os.Remove(indexFile.Name())
	addr := 0
	root := &directoryAsset{}
	err = filepath.Walk(source, func(asset string, info os.FileInfo, err error) error {
		assetName, _ := filepath.Rel(source, asset)
		assetName = filepath.ToSlash(assetName)
		if err != nil {
			return err
		}
		if info.IsDir() {
			root.addDirectory(assetName)
			return nil
		}
		file, err := os.OpenFile(asset, os.O_RDONLY, 0)
		if err != nil {
			return err
		}
		defer file.Close()
		fstat, _ := file.Stat()
		m := mime.TypeByExtension(path.Ext(strings.ToLower(asset)))
		if m == "" {
			m = "application/binary"
		}
		var compressed = false
		if params.CompressAssets && (strings.HasPrefix(m, "text/") || strings.HasSuffix(m, "+xml") ||
			strings.Contains(m, "javascript") || m == "application/xml") {
			compressed = true
		}
		var entry = fileAsset{
			name:         path.Base(assetName),
			mimeType:     m,
			size:         fstat.Size(),
			isCompressed: compressed,
		}
		addr, err = entry.writeObject(file, dataFile, addr, &params)
		if err != nil {
			return err
		}
		root.addFile(assetName, &entry)
		return nil
	})
	if err != nil {
		return nil
	}
	err = writeObjectFileFooter(dataFile, addr)
	if err != nil {
		return nil
	}
	err = writeGoIndex(indexFile, target, root, addr, &params)
	if err != nil {
		return err
	}
	dataFile.Close()
	indexFile.Close()
	err = os.Rename(dataFile.Name(), path.Join(target, "data.s"))
	if err != nil {
		return err
	}
	err = os.Rename(indexFile.Name(), path.Join(target, "index.go"))
	if err != nil {
		return err
	}
	return writeAsmIndex(target)
}
